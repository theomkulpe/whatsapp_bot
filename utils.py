# -*- coding: utf-8 -*-
"""test.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uhM0QH6yvhsekhIQAexC0rtCoy030KwQ

EXECUTING PHASE 1

Importing libraries
"""

from selenium import webdriver
from selenium.webdriver.chrome.service import Service as ChromeService
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.action_chains import ActionChains
from webdriver_manager.chrome import ChromeDriverManager
import time
import regex as re
from app_llm import ask



def open_whatsapp():
    options = webdriver.ChromeOptions()
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-dev-shm-usage')
    # options.add_argument('--headless')  # Uncomment if you don't need UI

    # Determine the user data directory based on the environment

    # user_data_dir = '/home/your_username/chrome_user_data'  # Adjust path for GCP VM

    user_data_dir = r'C:\Users\Om\Downloads\Chrome Session Data_'  # Path for local machine

    options.add_argument(f'--user-data-dir={user_data_dir}')

    driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
    driver.get('https://web.whatsapp.com')

    # Perform your WhatsApp actions here
    return driver


"""Declaring chats that you wish to access"""

GROUP_NAME = "Testing WhatsApp Bot"
USER_NAME = "Chirag Kedia"

"""Defining functions for pressing keyboard keys and using keyboard shortcuts"""

def press_enter(driver):
    actions = ActionChains(driver)
    actions.send_keys(Keys.ENTER).perform()

def press_escape(driver):
    actions = ActionChains(driver)
    actions.send_keys(Keys.ESCAPE).perform()

def click_search_icon(driver):
    actions = ActionChains(driver)
    actions.key_down(Keys.CONTROL).key_down(Keys.ALT).send_keys('/').key_up(Keys.ALT).key_up(Keys.CONTROL).perform()


# Dictionary to hold the mapping of action names to ActionChains statements
'''whatsapp_shortcuts = {
    'start_new_chat': lambda: actions.key_down(Keys.CONTROL).send_keys('n').key_up(Keys.CONTROL).perform(),
    'create_new_group': lambda: actions.key_down(Keys.CONTROL).key_down(Keys.SHIFT).send_keys('n').key_up(Keys.SHIFT).key_up(Keys.CONTROL).perform(),
    'next_chat': lambda: actions.key_down(Keys.CONTROL).key_down(Keys.SHIFT).send_keys(']').key_up(Keys.SHIFT).key_up(Keys.CONTROL).perform(),
    'previous_chat': lambda: actions.key_down(Keys.CONTROL).key_down(Keys.SHIFT).send_keys('[').key_up(Keys.SHIFT).key_up(Keys.CONTROL).perform(),
    'archive_chat': lambda: actions.key_down(Keys.CONTROL).send_keys('e').key_up(Keys.CONTROL).perform(),
    'mute_chat': lambda: actions.key_down(Keys.CONTROL).key_down(Keys.SHIFT).send_keys('m').key_up(Keys.SHIFT).key_up(Keys.CONTROL).perform(),
    'delete_chat': lambda: actions.key_down(Keys.CONTROL).send_keys(Keys.BACKSPACE).key_up(Keys.CONTROL).perform(),
    'mark_as_unread': lambda: actions.key_down(Keys.CONTROL).key_down(Keys.SHIFT).send_keys('u').key_up(Keys.SHIFT).key_up(Keys.CONTROL).perform(),
    'open_profile_status': lambda: actions.key_down(Keys.CONTROL).send_keys('p').key_up(Keys.CONTROL).perform(),
    'search_in_chat': lambda: actions.key_down(Keys.ALT).key_down(Keys.SHIFT).send_keys('f').key_up(Keys.SHIFT).key_up(Keys.ALT).perform(),
    'search': lambda: actions.key_down(Keys.CONTROL).key_down(Keys.ALT).send_keys('/').key_up(Keys.ALT).key_up(Keys.CONTROL).perform(),
    'zoom_in': lambda: actions.key_down(Keys.CONTROL).send_keys('=').key_up(Keys.CONTROL).perform(),
    'zoom_out': lambda: actions.key_down(Keys.CONTROL).send_keys('-').key_up(Keys.CONTROL).perform(),
    'zoom_reset': lambda: actions.key_down(Keys.CONTROL).send_keys('0').key_up(Keys.CONTROL).perform(),
    'settings': lambda: actions.key_down(Keys.CONTROL).send_keys(',').key_up(Keys.CONTROL).perform(),
    'edit_last_message': lambda: actions.send_keys(Keys.UP).perform(),
    'focus_emoji_button': lambda: actions.key_down(Keys.SHIFT).send_keys(Keys.TAB).key_up(Keys.SHIFT).perform(),
    'focus_text_input': lambda: actions.key_down(Keys.CONTROL).key_down(Keys.SHIFT).send_keys('i').key_up(Keys.SHIFT).key_up(Keys.CONTROL).perform()
}'''

"""Basic functions"""

def go_to_home_page(driver):

    press_escape(driver)

    search_icon = driver.find_element(By.XPATH, '//span[@data-icon="search"]')
    search_icon.click()

"""Checking Unread Messages"""

def check_unread_messages(driver, chat_name):

    actions = ActionChains(driver)

    go_to_home_page(driver)

    actions.send_keys(chat_name).perform()

    actions.send_keys(Keys.DOWN).perform()

    time.sleep(1)

    try:
        # Locate the highlighted chat element by its unique class '_ak7p'
        highlighted_chat = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.XPATH, f"//div[contains(@class, '_ak7p')]"))
        )

        # Now within this highlighted chat element, attempt to find the unread message indicator
        unread_indicator = highlighted_chat.find_element(By.XPATH, ".//span[contains(@aria-label, 'unread message')]")
        unread_count = unread_indicator.text
        unread_count = int(unread_count)

        return True, unread_count

    except Exception as e:
        print(f"No unread messages found for '{chat_name}': {e}")
        return False, None

"""Extracting unread messages where user has been mentioned"""

def extract_unread_messages_with_mention(driver, group_name, user_name):
    '''Here,
    group_name is the name of the group from where you want to extract the messages
    user_name is the name of the user who has been mentioned in the messages that you want to extract'''

    actions = ActionChains(driver)

    has_unread, unread_count = check_unread_messages(driver, group_name)

    if has_unread:

        try:
            # Open the chat by clicking on the search result
            '''chat = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.XPATH, f"//span[@title='{group_name}']"))
            )
            chat.click()'''

            press_enter(driver)

            # Wait a bit for the chat to open and messages to load
            time.sleep(2)

            # Find all message bubbles in the chat
            messages = WebDriverWait(driver, 10).until(
                EC.presence_of_all_elements_located((By.XPATH, '//div[contains(@class, "message-in")]'))
            )

            # Extract text from each unread message
            unread_messages = []
            for message in messages[int(unread_count) * -1:]:
                try:
                        message_text = message.find_element(By.CSS_SELECTOR, 'span.selectable-text').text

                        if f"@{user_name}" in message_text:
                            metadata = message.find_element(By.XPATH, './/div[contains(@class, "copyable-text")]').get_attribute('data-pre-plain-text')
                            unread_messages.append((metadata, message_text),)

                except Exception as e:
                    print(f"Error reading message: {e}")
                    continue

            go_to_home_page(driver)

            return unread_messages

        except Exception as e:
            print(f"An error occurred while extracting unread messages: {e}")

            go_to_home_page(driver)

            return []

"""Generating responses and saving (message data, response) as (key, value) pairs in a dictionary"""

def generate_responses_to_messages(unread_messages):
    '''This function returns a dictionary, which holds pairs of a tuple and a string, like
    {
    ('[12:14 pm, 19/05/2024] User 1: ', '@Chirag Kedia extracted message 1'): 'response 1',
    ('[12:14 pm, 19/05/2024] User 1: ', 'extracted message 2, @Chirag Kedia?'): 'response 2',
    ('[12:15 pm, 19/05/2024] User 1: ', '@Chirag Kedia extracted message three'): 'response 3'
    }
    '''

    messages_and_responses = dict()

    for i in unread_messages:
        message = i[1]

        try:
            message = message.replace("@{Chirag Kedia}", "")
        except:
            continue

        response = ask(message)
        messages_and_responses[i] = response


    return messages_and_responses

"""Sending approval messages to the user"""

def send_approval_messages(driver, user_name, messages_and_responses):

    actions = ActionChains(driver)

    actions.key_down(Keys.CONTROL).key_down(Keys.ALT).send_keys('/').key_up(Keys.ALT).key_up(Keys.CONTROL).perform()

    actions.send_keys("User 1").perform() #########################

    time.sleep(1)

    press_enter(driver)

    # search_box = search_for_chat(user_name)

    try:

        '''chat = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.XPATH, "//span[contains(@class, '_ao3e') and contains(@class, 'x1iyjqo2')]/span[@class='matched-text _ao3e' and text()='User 1']"))
        )

        chat.click()




        message_box = WebDriverWait(driver, 20).until(
            EC.element_to_be_clickable((By.XPATH, '//div[@contenteditable="true"][@data-tab="10"]'))
        )

        # Create an ActionChains object to send keys

        actions.move_to_element(message_box)'''

        for message_data, response in messages_and_responses.items():



            approval_request = f'''{message_data[0]}
{message_data[1]}

Should I reply with:
{response}'''



            # Split the message by newline and type each part, then press SHIFT+ENTER
            for part in approval_request.split('\n'):
                actions.send_keys(part)
                actions.key_down(Keys.SHIFT).send_keys(Keys.ENTER).key_up(Keys.SHIFT)

            # Finally, send the message by pressing ENTER
            actions.send_keys(Keys.ENTER)
            actions.perform()

    except Exception as e:
        print(f"An error occurred while sending approval: {e}")

    go_to_home_page(driver)

"""Checking user's response to the approval requests"""

def check_for_yes_in_replies(driver, user_name):

    actions = ActionChains(driver)

    has_unread, unread_count = check_unread_messages(driver, "User 1") ##################

    if has_unread:

        actions.send_keys(Keys.ENTER).perform()

        # Wait a bit for the chat to open and messages to load
        time.sleep(2)

        # Find all message bubbles in the chat
        messages = WebDriverWait(driver, 10).until(
            EC.presence_of_all_elements_located((By.XPATH, '//div[contains(@class, "message-in")]'))
        )
        approved_messages = []
        time.sleep(3)  # Wait for all messages to be loaded

        # Find all received messages
        messages = WebDriverWait(driver, 10).until(
            EC.presence_of_all_elements_located((By.XPATH, '//div[contains(@class, "message-in")]'))
        )

        for message in messages[unread_count * -1:]:
                # Check if this message contains the word 'yes'
                if 'yes' in message.text.lower():
                    # Find the quoted message part to print the original message
                    quoted_message = message.find_element(By.XPATH, './/span[contains(@class, "quoted-mention _ao3e")]')
                    if quoted_message:
                        original_message = quoted_message.get_attribute('innerHTML')
                        lines = original_message.split("\n")
                        approved_messages.append((lines[0], lines[1]))


        return approved_messages

    go_to_home_page(driver)

"""Replying to messages"""

def send_responses_to_group(driver, group_name, messages_and_responses, approved_messages):

    actions = ActionChains(driver)

    actions.key_down(Keys.CONTROL).key_down(Keys.ALT).send_keys('/').key_up(Keys.ALT).key_up(Keys.CONTROL).perform()

    '''chat = WebDriverWait(driver, 10).until(
        EC.presence_of_element_located((By.XPATH, f"//span[@title='{group_name}']"))
    )
    chat.click()'''

    time.sleep(1)

    press_enter(driver)


    messages = WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.XPATH, "//span[@class='matched-text _ao3e' and text()='User 1']")))

    for message in messages:

        msg_text = message.find_element(By.CSS_SELECTOR, 'span.selectable-text').text
        metadata = message.find_element(By.XPATH, './/div[contains(@class, "copyable-text")]').get_attribute('data-pre-plain-text')
        identifier = (metadata, msg_text)

        if identifier in approved_messages:
            reply_text = messages_and_responses[identifier]

            message_text_element = message.find_element(By.CSS_SELECTOR, 'span.selectable-text')

            actions.move_to_element(message_text_element).perform()
            time.sleep(1)  # Small delay to ensure menu button appears

            # Click on the menu button to open the message options
            menu_button = message.find_element(By.XPATH, './/span[@data-icon="down-context"]')
            menu_button.click()

            # Wait and click the 'Reply' button in the context menu
            reply_button = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.XPATH, '//div[@aria-label="Reply"]'))
            )
            reply_button.click()

            # Wait for the reply input box to be active and enter the reply text
            reply_input = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.XPATH, '//div[@contenteditable="true"][@data-tab="10"]'))
            )
            reply_input.send_keys(reply_text + Keys.ENTER)

    go_to_home_page(driver)

"""--------------------------------------------------------------------"""

def extract_messages_generate_responses_and_ask_approval(driver, group_name, user_name):
    '''This function extracts messages from a group chat (group_name)
    in which a particular person (user_name) has been mentioned,
    generates responses to these messages, and then
    sends the messages and responses to the person's DM (user_name) for approval'''

    unread_messages = extract_unread_messages_with_mention(driver, group_name, user_name)

    messages_and_responses = generate_responses_to_messages(unread_messages)

    send_approval_messages(driver, "User 1", messages_and_responses)

    return messages_and_responses

def check_approval_and_send_responses(driver, group_name, user_name, messages_and_responses):
    '''This function sends the responses approved by the person (user_name) to the group chat (group_name)'''

    approved_messages = check_for_yes_in_replies(driver, "User 1")

    send_responses_to_group(driver, group_name, messages_and_responses, approved_messages)
